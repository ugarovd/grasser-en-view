(function (e, a) { "object" == typeof exports && "undefined" != typeof module ? a(exports) : "function" == typeof define && define.amd ? define(["exports"], a) : (e = "undefined" == typeof globalThis ? e || self : globalThis, a(e.IMask = {})) })(this, function (e) { 'use strict'; function a(e) { return "string" == typeof e || e instanceof String } function t(e) { var a; return "object" == typeof e && null != e && "Object" === (null == e || null == (a = e.constructor) ? void 0 : a.name) } function n(e, a) { return Array.isArray(a) ? n(e, (e, t) => a.includes(t)) : Object.entries(e).reduce((e, t) => { let [n, s] = t; return a(s, n) && (e[n] = s), e }, {}) } function s(e) { return e === k.LEFT ? k.FORCE_LEFT : e === k.RIGHT ? k.FORCE_RIGHT : e } function r(e) { return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1") } function l(e, t) { if (t === e) return !0; const a = Array.isArray(t), n = Array.isArray(e); let s; if (a && n) { if (t.length != e.length) return !1; for (s = 0; s < t.length; s++)if (!l(t[s], e[s])) return !1; return !0 } if (a != n) return !1; if (t && e && "object" == typeof t && "object" == typeof e) { const a = t instanceof Date, n = e instanceof Date; if (a && n) return t.getTime() == e.getTime(); if (a != n) return !1; const r = t instanceof RegExp, o = e instanceof RegExp; if (r && o) return t.toString() == e.toString(); if (r != o) return !1; const i = Object.keys(t); for (s = 0; s < i.length; s++)if (!Object.prototype.hasOwnProperty.call(e, i[s])) return !1; for (s = 0; s < i.length; s++)if (!l(e[i[s]], t[i[s]])) return !1; return !0 } return !!(t && e && "function" == typeof t && "function" == typeof e) && t.toString() === e.toString() } function o(e, a) { return new o.InputMask(e, a) } function i(e) { if (null == e) throw new Error("mask property should be defined"); return e instanceof RegExp ? o.MaskedRegExp : a(e) ? o.MaskedPattern : e === Date ? o.MaskedDate : e === Number ? o.MaskedNumber : Array.isArray(e) || e === Array ? o.MaskedDynamic : o.Masked && e.prototype instanceof o.Masked ? e : o.Masked && e instanceof o.Masked ? e.constructor : e instanceof Function ? o.MaskedFunction : (console.warn("Mask not found for mask", e), o.Masked) } function u(e) { if (!e) throw new Error("Options in not defined"); if (o.Masked) { if (e.prototype instanceof o.Masked) return { mask: e }; const { mask: s = void 0, ...a } = e instanceof o.Masked ? { mask: e } : t(e) && e.mask instanceof o.Masked ? e : {}; if (s) { const e = s.mask; return { ...n(s, (e, a) => !a.startsWith("_")), mask: s.constructor, _mask: e, ...a } } } return t(e) ? { ...e } : { mask: e } } function d(e) { if (o.Masked && e instanceof o.Masked) return e; const a = u(e), t = i(a.mask); if (!t) throw new Error("Masked class is not found for provided mask, appropriate module needs to be imported manually before creating mask."); return a.mask === t && delete a.mask, a._mask && (a.mask = a._mask, delete a._mask), new t(a) } function p(e, a, t) { void 0 === a && (a = w.MASKED), void 0 === t && (t = w.MASKED); const n = d(e); return e => n.runIsolated(n => (n[a] = e, n[t])) } function c(e, a, t, n) { return p(a, t, n)(e) } const k = { NONE: "NONE", LEFT: "LEFT", FORCE_LEFT: "FORCE_LEFT", RIGHT: "RIGHT", FORCE_RIGHT: "FORCE_RIGHT" }; class g { constructor(e) { for (Object.assign(this, e); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);)--this.oldSelection.start } get startChangePos() { return Math.min(this.cursorPos, this.oldSelection.start) } get insertedCount() { return this.cursorPos - this.startChangePos } get inserted() { return this.value.substr(this.startChangePos, this.insertedCount) } get removedCount() { return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0) } get removed() { return this.oldValue.substr(this.startChangePos, this.removedCount) } get head() { return this.value.substring(0, this.startChangePos) } get tail() { return this.value.substring(this.startChangePos + this.insertedCount) } get removeDirection() { return !this.removedCount || this.insertedCount ? k.NONE : (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && this.oldSelection.end === this.oldSelection.start ? k.RIGHT : k.LEFT } } o.createMask = d; class m { get selectionStart() { let e; try { e = this._unsafeSelectionStart } catch { } return null == e ? this.value.length : e } get selectionEnd() { let e; try { e = this._unsafeSelectionEnd } catch { } return null == e ? this.value.length : e } select(e, a) { if (null != e && null != a && (e !== this.selectionStart || a !== this.selectionEnd)) try { this._unsafeSelect(e, a) } catch { } } get isActive() { return !1 } } o.MaskElement = m; class h extends m { constructor(e) { super(), this.input = e, this._handlers = {} } get rootElement() { var e, a, t; return null == (e = null == (a = (t = this.input).getRootNode) ? void 0 : a.call(t)) ? document : e } get isActive() { return this.input === this.rootElement.activeElement } bindEvents(e) { Object.keys(e).forEach(a => this._toggleEventHandler(h.EVENTS_MAP[a], e[a])) } unbindEvents() { Object.keys(this._handlers).forEach(e => this._toggleEventHandler(e)) } _toggleEventHandler(e, a) { this._handlers[e] && (this.input.removeEventListener(e, this._handlers[e]), delete this._handlers[e]), a && (this.input.addEventListener(e, a), this._handlers[e] = a) } } h.EVENTS_MAP = { selectionChange: "keydown", input: "input", drop: "drop", click: "click", focus: "focus", commit: "blur" }, o.HTMLMaskElement = h; class _ extends h { constructor(e) { super(e), this.input = e, this._handlers = {} } get _unsafeSelectionStart() { return null == this.input.selectionStart ? this.value.length : this.input.selectionStart } get _unsafeSelectionEnd() { return this.input.selectionEnd } _unsafeSelect(e, a) { this.input.setSelectionRange(e, a) } get value() { return this.input.value } set value(e) { this.input.value = e } } o.HTMLMaskElement = h; class f extends h { get _unsafeSelectionStart() { const e = this.rootElement, a = e.getSelection && e.getSelection(), t = a && a.anchorOffset, n = a && a.focusOffset; return null == n || null == t || t < n ? t : n } get _unsafeSelectionEnd() { const e = this.rootElement, a = e.getSelection && e.getSelection(), t = a && a.anchorOffset, n = a && a.focusOffset; return null == n || null == t || t > n ? t : n } _unsafeSelect(e, a) { if (!this.rootElement.createRange) return; const t = this.rootElement.createRange(); t.setStart(this.input.firstChild || this.input, e), t.setEnd(this.input.lastChild || this.input, a); const n = this.rootElement, s = n.getSelection && n.getSelection(); s && (s.removeAllRanges(), s.addRange(t)) } get value() { return this.input.textContent || "" } set value(e) { this.input.textContent = e } } o.HTMLContenteditableMaskElement = f; class v { constructor(e, a) { this.el = e instanceof m ? e : e.isContentEditable && "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName ? new f(e) : new _(e), this.masked = d(a), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange() } maskEquals(e) { var a; return null == e || (null == (a = this.masked) ? void 0 : a.maskEquals(e)) } get mask() { return this.masked.mask } set mask(e) { if (!this.maskEquals(e)) { if (!(e instanceof o.Masked) && this.masked.constructor === i(e)) return void this.masked.updateOptions({ mask: e }); const a = e instanceof o.Masked ? e : d({ mask: e }); a.unmaskedValue = this.masked.unmaskedValue, this.masked = a } } get value() { return this._value } set value(e) { this.value === e || (this.masked.value = e, this.updateControl(), this.alignCursor()) } get unmaskedValue() { return this._unmaskedValue } set unmaskedValue(e) { this.unmaskedValue === e || (this.masked.unmaskedValue = e, this.updateControl(), this.alignCursor()) } get typedValue() { return this.masked.typedValue } set typedValue(e) { this.masked.typedValueEquals(e) || (this.masked.typedValue = e, this.updateControl(), this.alignCursor()) } get displayValue() { return this.masked.displayValue } _bindEvents() { this.el.bindEvents({ selectionChange: this._saveSelection, input: this._onInput, drop: this._onDrop, click: this._onClick, focus: this._onFocus, commit: this._onChange }) } _unbindEvents() { this.el && this.el.unbindEvents() } _fireEvent(a, t) { const e = this._listeners[a]; e && e.forEach(e => e(t)) } get selectionStart() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart } get cursorPos() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd } set cursorPos(e) { this.el && this.el.isActive && (this.el.select(e, e), this._saveSelection()) } _saveSelection() { this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = { start: this.selectionStart, end: this.cursorPos } } updateValue() { this.masked.value = this.el.value, this._value = this.masked.value } updateControl() { const e = this.masked.unmaskedValue, a = this.masked.value, t = this.displayValue, n = this.unmaskedValue !== e || this.value !== a; this._unmaskedValue = e, this._value = a, this.el.value !== t && (this.el.value = t), n && this._fireChangeEvents() } updateOptions(e) { const { mask: a, ...t } = e, n = !this.maskEquals(a), s = !l(this.masked, t); n && (this.mask = a), s && this.masked.updateOptions(t), (n || s) && this.updateControl() } updateCursor(e) { null == e || (this.cursorPos = e, this._delayUpdateCursor(e)) } _delayUpdateCursor(e) { this._abortUpdateCursor(), this._changingCursorPos = e, this._cursorChanging = setTimeout(() => { this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor()) }, 10) } _fireChangeEvents() { this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent) } _abortUpdateCursor() { this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging) } alignCursor() { this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, k.LEFT)) } alignCursorFriendly() { this.selectionStart !== this.cursorPos || this.alignCursor() } on(e, a) { return this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(a), this } off(e, a) { if (!this._listeners[e]) return this; if (!a) return delete this._listeners[e], this; const t = this._listeners[e].indexOf(a); return 0 <= t && this._listeners[e].splice(t, 1), this } _onInput(a) { if (this._inputEvent = a, this._abortUpdateCursor(), !this._selection) return this.updateValue(); const e = new g({ value: this.el.value, cursorPos: this.cursorPos, oldValue: this.displayValue, oldSelection: this._selection }), t = this.masked.rawInputValue, n = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection, { input: !0, raw: !0 }).offset, s = t === this.masked.rawInputValue ? e.removeDirection : k.NONE; let r = this.masked.nearestInputPos(e.startChangePos + n, s); s !== k.NONE && (r = this.masked.nearestInputPos(r, k.NONE)), this.updateControl(), this.updateCursor(r), delete this._inputEvent } _onChange() { this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection() } _onDrop(e) { e.preventDefault(), e.stopPropagation() } _onFocus() { this.alignCursorFriendly() } _onClick() { this.alignCursorFriendly() } destroy() { this._unbindEvents(), this._listeners.length = 0, delete this.el } } o.InputMask = v; class E { static normalize(e) { return Array.isArray(e) ? e : [e, new E] } constructor(e) { Object.assign(this, { inserted: "", rawInserted: "", skip: !1, tailShift: 0 }, e) } aggregate(e) { return this.rawInserted += e.rawInserted, this.skip = this.skip || e.skip, this.inserted += e.inserted, this.tailShift += e.tailShift, this } get offset() { return this.tailShift + this.inserted.length } } o.ChangeDetails = E; class S { constructor(e, a, t) { void 0 === e && (e = ""), void 0 === a && (a = 0), this.value = e, this.from = a, this.stop = t } toString() { return this.value } extend(e) { this.value += e + "" } appendTo(e) { return e.append(this.toString(), { tail: !0 }).aggregate(e._appendPlaceholder()) } get state() { return { value: this.value, from: this.from, stop: this.stop } } set state(e) { Object.assign(this, e) } unshift(e) { if (!this.value.length || null != e && this.from >= e) return ""; const a = this.value[0]; return this.value = this.value.slice(1), a } shift() { if (!this.value.length) return ""; const e = this.value[this.value.length - 1]; return this.value = this.value.slice(0, -1), e } } class M { constructor(e) { this._value = "", this._update({ ...M.DEFAULTS, ...e }), this._initialized = !0 } updateOptions(e) { Object.keys(e).length && this.withValueRefresh(this._update.bind(this, e)) } _update(e) { Object.assign(this, e) } get state() { return { _value: this.value, _rawInputValue: this.rawInputValue } } set state(e) { this._value = e._value } reset() { this._value = "" } get value() { return this._value } set value(e) { this.resolve(e, { input: !0 }) } resolve(e, a) { void 0 === a && (a = { input: !0 }), this.reset(), this.append(e, a, ""), this.doCommit() } get unmaskedValue() { return this.value } set unmaskedValue(e) { this.resolve(e, {}) } get typedValue() { return this.parse ? this.parse(this.value, this) : this.unmaskedValue } set typedValue(e) { this.format ? this.value = this.format(e, this) : this.unmaskedValue = e + "" } get rawInputValue() { return this.extractInput(0, this.value.length, { raw: !0 }) } set rawInputValue(e) { this.resolve(e, { raw: !0 }) } get displayValue() { return this.value } get isComplete() { return !0 } get isFilled() { return this.isComplete } nearestInputPos(e) { return e } totalInputPositions(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), Math.min(this.value.length, a - e) } extractInput(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), this.value.slice(e, a) } extractTail(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), new S(this.extractInput(e, a), e) } appendTail(e) { return a(e) && (e = new S(e + "")), e.appendTo(this) } _appendCharRaw(e) { return e ? (this._value += e, new E({ inserted: e, rawInserted: e })) : new E } _appendChar(e, a, t) { void 0 === a && (a = {}); const n = this.state; let s; if ([e, s] = this.doPrepareChar(e, a), s = s.aggregate(this._appendCharRaw(e, a)), s.inserted) { let e, r = !1 !== this.doValidate(a); if (r && null != t) { const a = this.state; !0 === this.overwrite && (e = t.state, t.unshift(this.value.length - s.tailShift)); let n = this.appendTail(t); r = n.rawInserted === t.toString(), r && n.inserted || "shift" !== this.overwrite || (this.state = a, e = t.state, t.shift(), n = this.appendTail(t), r = n.rawInserted === t.toString()), r && n.inserted && (this.state = a) } r || (s = new E, this.state = n, t && e && (t.state = e)) } return s } _appendPlaceholder() { return new E } _appendEager() { return new E } append(e, t, n) { if (!a(e)) throw new Error("value should be string"); const s = a(n) ? new S(n + "") : n; null != t && t.tail && (t._beforeTailState = this.state); let r;[e, r] = this.doPrepare(e, t); for (let a = 0; a < e.length; ++a) { const n = this._appendChar(e[a], t, s); if (!n.rawInserted && !this.doSkipInvalid(e[a], t, s)) break; r.aggregate(n) } return (!0 === this.eager || "append" === this.eager) && null != t && t.input && e && r.aggregate(this._appendEager()), null != s && (r.tailShift += this.appendTail(s).tailShift), r } remove(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), this._value = this.value.slice(0, e) + this.value.slice(a), new E } withValueRefresh(e) { if (this._refreshing || !this._initialized) return e(); this._refreshing = !0; const a = this.rawInputValue, t = this.value, n = e(); return this.rawInputValue = a, this.value && this.value !== t && 0 === t.indexOf(this.value) && this.append(t.slice(this.value.length), {}, ""), delete this._refreshing, n } runIsolated(e) { if (this._isolated || !this._initialized) return e(this); this._isolated = !0; const a = this.state, t = e(this); return this.state = a, delete this._isolated, t } doSkipInvalid() { return !!this.skipInvalid } doPrepare(e, a) { return void 0 === a && (a = {}), E.normalize(this.prepare ? this.prepare(e, this, a) : e) } doPrepareChar(e, a) { return void 0 === a && (a = {}), E.normalize(this.prepareChar ? this.prepareChar(e, this, a) : e) } doValidate(e) { return (!this.validate || this.validate(this.value, this, e)) && (!this.parent || this.parent.doValidate(e)) } doCommit() { this.commit && this.commit(this.value, this) } splice(e, a, t, n, r) { void 0 === n && (n = k.NONE), void 0 === r && (r = { input: !0 }); const l = e + a, o = this.extractTail(l), i = !0 === this.eager || "remove" === this.eager; let u; i && (n = s(n), u = this.extractInput(0, l, { raw: !0 })); let d = e; const p = new E; if (n !== k.NONE && (d = this.nearestInputPos(e, 1 < a && 0 !== e && !i ? k.NONE : n), p.tailShift = d - e), p.aggregate(this.remove(d)), i && n !== k.NONE && u === this.rawInputValue) if (n === k.FORCE_LEFT) for (let e; u === this.rawInputValue && (e = this.value.length);)p.aggregate(new E({ tailShift: -1 })).aggregate(this.remove(e - 1)); else n === k.FORCE_RIGHT && o.unshift(); return p.aggregate(this.append(t, r, o)) } maskEquals(e) { return this.mask === e } typedValueEquals(e) { const a = this.typedValue; return e === a || M.EMPTY_VALUES.includes(e) && M.EMPTY_VALUES.includes(a) || !!this.format && this.format(e, this) === this.format(this.typedValue, this) } } M.DEFAULTS = { skipInvalid: !0 }, M.EMPTY_VALUES = [void 0, null, ""], o.Masked = M; class C { constructor(e, a) { void 0 === e && (e = []), void 0 === a && (a = 0), this.chunks = e, this.from = a } toString() { return this.chunks.map(String).join("") } extend(e) { if (!(e + "")) return; e = a(e) ? new S(e + "") : e; const t = this.chunks[this.chunks.length - 1], n = t && (t.stop === e.stop || null == e.stop) && e.from === t.from + t.toString().length; if (e instanceof S) n ? t.extend(e.toString()) : this.chunks.push(e); else if (e instanceof C) { if (null == e.stop) for (let a; e.chunks.length && null == e.chunks[0].stop;)a = e.chunks.shift(), a.from += e.from, this.extend(a); e.toString() && (e.stop = e.blockIndex, this.chunks.push(e)) } } appendTo(e) { if (!(e instanceof o.MaskedPattern)) { const a = new S(this.toString()); return a.appendTo(e) } const a = new E; for (let t = 0; t < this.chunks.length && !a.skip; ++t) { const n = this.chunks[t], s = e._mapPosToBlock(e.value.length), r = n.stop; let l; if (null != r && (!s || s.index <= r)) { if (n instanceof C || 0 <= e._stops.indexOf(r)) { const t = e._appendPlaceholder(r); a.aggregate(t) } l = n instanceof C && e._blocks[r] } if (l) { const t = l.appendTail(n); t.skip = !1, a.aggregate(t), e._value += t.inserted; const s = n.toString().slice(t.rawInserted.length); s && a.aggregate(e.append(s, { tail: !0 })) } else a.aggregate(e.append(n.toString(), { tail: !0 })) } return a } get state() { return { chunks: this.chunks.map(e => e.state), from: this.from, stop: this.stop, blockIndex: this.blockIndex } } set state(e) { const { chunks: a, ...t } = e; Object.assign(this, t), this.chunks = a.map(e => { const a = "chunks" in e ? new C : new S; return a.state = e, a }) } unshift(e) { if (!this.chunks.length || null != e && this.from >= e) return ""; const a = null == e ? e : e - this.from; for (let t = 0; t < this.chunks.length;) { const e = this.chunks[t], n = e.unshift(a); if (e.toString()) { if (!n) break; ++t } else this.chunks.splice(t, 1); if (n) return n } return "" } shift() { if (!this.chunks.length) return ""; for (let e = this.chunks.length - 1; 0 <= e;) { const a = this.chunks[e], t = a.shift(); if (a.toString()) { if (!t) break; --e } else this.chunks.splice(e, 1); if (t) return t } return "" } } class T { constructor(e, a) { this.masked = e, this._log = []; const { offset: t, index: n } = e._mapPosToBlock(a) || (0 > a ? { index: 0, offset: 0 } : { index: this.masked._blocks.length, offset: 0 }); this.offset = t, this.index = n, this.ok = !1 } get block() { return this.masked._blocks[this.index] } get pos() { return this.masked._blockStartPos(this.index) + this.offset } get state() { return { index: this.index, offset: this.offset, ok: this.ok } } set state(e) { Object.assign(this, e) } pushState() { this._log.push(this.state) } popState() { const e = this._log.pop(); return e && (this.state = e), e } bindBlock() { this.block || (0 > this.index && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.value.length)) } _pushLeft(e) { for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = (null == (a = this.block) ? void 0 : a.value.length) || 0) { var a; if (e()) return this.ok = !0 } return this.ok = !1 } _pushRight(e) { for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0)if (e()) return this.ok = !0; return this.ok = !1 } pushLeftBeforeFilled() { return this._pushLeft(() => { if (!this.block.isFixed && this.block.value && (this.offset = this.block.nearestInputPos(this.offset, k.FORCE_LEFT), 0 !== this.offset)) return !0 }) } pushLeftBeforeInput() { return this._pushLeft(() => { if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, k.LEFT), !0 }) } pushLeftBeforeRequired() { return this._pushLeft(() => { if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, k.LEFT), !0 }) } pushRightBeforeFilled() { return this._pushRight(() => { if (!this.block.isFixed && this.block.value && (this.offset = this.block.nearestInputPos(this.offset, k.FORCE_RIGHT), this.offset !== this.block.value.length)) return !0 }) } pushRightBeforeInput() { return this._pushRight(() => { if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, k.NONE), !0 }) } pushRightBeforeRequired() { return this._pushRight(() => { if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, k.NONE), !0 }) } } class b { constructor(e) { Object.assign(this, e), this._value = "", this.isFixed = !0 } get value() { return this._value } get unmaskedValue() { return this.isUnmasking ? this.value : "" } get rawInputValue() { return this._isRawInput ? this.value : "" } get displayValue() { return this.value } reset() { this._isRawInput = !1, this._value = "" } remove(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this._value.length), this._value = this._value.slice(0, e) + this._value.slice(a), this._value || (this._isRawInput = !1), new E } nearestInputPos(e, a) { void 0 === a && (a = k.NONE); const t = this._value.length; switch (a) { case k.LEFT: case k.FORCE_LEFT: return 0; case k.NONE: case k.RIGHT: case k.FORCE_RIGHT: default: return t; } } totalInputPositions(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this._value.length), this._isRawInput ? a - e : 0 } extractInput(e, a, t) { return void 0 === e && (e = 0), void 0 === a && (a = this._value.length), void 0 === t && (t = {}), t.raw && this._isRawInput && this._value.slice(e, a) || "" } get isComplete() { return !0 } get isFilled() { return !!this._value } _appendChar(e, a) { void 0 === a && (a = {}); const t = new E; if (this.isFilled) return t; const n = !0 === this.eager || "append" === this.eager, s = this.char === e, r = s && (this.isUnmasking || a.input || a.raw) && (!a.raw || !n) && !a.tail; return r && (t.rawInserted = this.char), this._value = t.inserted = this.char, this._isRawInput = r && (a.raw || a.input), t } _appendEager() { return this._appendChar(this.char, { tail: !0 }) } _appendPlaceholder() { const e = new E; return this.isFilled ? e : (this._value = e.inserted = this.char, e) } extractTail() { return new S("") } appendTail(e) { return a(e) && (e = new S(e + "")), e.appendTo(this) } append(e, a, t) { const n = this._appendChar(e[0], a); return null != t && (n.tailShift += this.appendTail(t).tailShift), n } doCommit() { } get state() { return { _value: this._value, _rawInputValue: this.rawInputValue } } set state(e) { this._value = e._value, this._isRawInput = !!e._rawInputValue } } class x { constructor(e) { const { parent: a, isOptional: t, placeholderChar: n, displayChar: s, lazy: r, eager: l, ...o } = e; this.masked = d(o), Object.assign(this, { parent: a, isOptional: t, placeholderChar: n, displayChar: s, lazy: r, eager: l }) } reset() { this.isFilled = !1, this.masked.reset() } remove(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), 0 === e && 1 <= a ? (this.isFilled = !1, this.masked.remove(e, a)) : new E } get value() { return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "") } get unmaskedValue() { return this.masked.unmaskedValue } get rawInputValue() { return this.masked.rawInputValue } get displayValue() { return this.masked.value && this.displayChar || this.value } get isComplete() { return !!this.masked.value || this.isOptional } _appendChar(e, a) { if (void 0 === a && (a = {}), this.isFilled) return new E; const t = this.masked.state, n = this.masked._appendChar(e, this.currentMaskFlags(a)); return n.inserted && !1 === this.doValidate(a) && (n.inserted = n.rawInserted = "", this.masked.state = t), n.inserted || this.isOptional || this.lazy || a.input || (n.inserted = this.placeholderChar), n.skip = !n.inserted && !this.isOptional, this.isFilled = !!n.inserted, n } append(e, a, t) { return this.masked.append(e, this.currentMaskFlags(a), t) } _appendPlaceholder() { const e = new E; return this.isFilled || this.isOptional ? e : (this.isFilled = !0, e.inserted = this.placeholderChar, e) } _appendEager() { return new E } extractTail(e, a) { return this.masked.extractTail(e, a) } appendTail(e) { return this.masked.appendTail(e) } extractInput(e, a, t) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), this.masked.extractInput(e, a, t) } nearestInputPos(e, a) { void 0 === a && (a = k.NONE); const t = this.value.length, n = Math.min(Math.max(e, 0), t); switch (a) { case k.LEFT: case k.FORCE_LEFT: return this.isComplete ? n : 0; case k.RIGHT: case k.FORCE_RIGHT: return this.isComplete ? n : t; case k.NONE: default: return n; } } totalInputPositions(e, a) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), this.value.slice(e, a).length } doValidate(e) { return this.masked.doValidate(this.currentMaskFlags(e)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(e))) } doCommit() { this.masked.doCommit() } get state() { return { _value: this.value, _rawInputValue: this.rawInputValue, masked: this.masked.state, isFilled: this.isFilled } } set state(e) { this.masked.state = e.masked, this.isFilled = e.isFilled } currentMaskFlags(e) { var a; return { ...e, _beforeTailState: (null == e || null == (a = e._beforeTailState) ? void 0 : a.masked) || (null == e ? void 0 : e._beforeTailState) } } } x.DEFAULT_DEFINITIONS = { 0: /\d/, a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, "*": /./ }; class I extends M { updateOptions(e) { super.updateOptions(e) } _update(e) { const a = e.mask; a && (e.validate = e => 0 <= e.search(a)), super._update(e) } } o.MaskedRegExp = I; class F extends M { constructor(e) { super({ ...F.DEFAULTS, ...e, definitions: Object.assign({}, x.DEFAULT_DEFINITIONS, null == e ? void 0 : e.definitions) }) } updateOptions(e) { super.updateOptions(e) } _update(e) { e.definitions = Object.assign({}, this.definitions, e.definitions), super._update(e), this._rebuildMask() } _rebuildMask() { const e = this.definitions; this._blocks = [], this._stops = [], this._maskedBlocks = {}; const a = this.mask; if (!a || !e) return; let t = !1, n = !1; for (let s = 0; s < a.length; ++s) { if (this.blocks) { const e = a.slice(s), t = Object.keys(this.blocks).filter(a => 0 === e.indexOf(a)); t.sort((e, a) => a.length - e.length); const n = t[0]; if (n) { const e = d({ lazy: this.lazy, eager: this.eager, placeholderChar: this.placeholderChar, displayChar: this.displayChar, overwrite: this.overwrite, ...u(this.blocks[n]), parent: this }); e && (this._blocks.push(e), !this._maskedBlocks[n] && (this._maskedBlocks[n] = []), this._maskedBlocks[n].push(this._blocks.length - 1)), s += n.length - 1; continue } } let r = a[s], l = (r in e); if (r === F.STOP_CHAR) { this._stops.push(this._blocks.length); continue } if ("{" === r || "}" === r) { t = !t; continue } if ("[" === r || "]" === r) { n = !n; continue } if (r === F.ESCAPE_CHAR) { if (++s, r = a[s], !r) break; l = !1 } const o = l ? new x({ isOptional: n, lazy: this.lazy, eager: this.eager, placeholderChar: this.placeholderChar, displayChar: this.displayChar, ...u(e[r]), parent: this }) : new b({ char: r, eager: this.eager, isUnmasking: t }); this._blocks.push(o) } } get state() { return { ...super.state, _blocks: this._blocks.map(e => e.state) } } set state(e) { const { _blocks: a, ...t } = e; this._blocks.forEach((e, t) => e.state = a[t]), super.state = t } reset() { super.reset(), this._blocks.forEach(e => e.reset()) } get isComplete() { return this._blocks.every(e => e.isComplete) } get isFilled() { return this._blocks.every(e => e.isFilled) } get isFixed() { return this._blocks.every(e => e.isFixed) } get isOptional() { return this._blocks.every(e => e.isOptional) } doCommit() { this._blocks.forEach(e => e.doCommit()), super.doCommit() } get unmaskedValue() { return this._blocks.reduce((e, a) => e += a.unmaskedValue, "") } set unmaskedValue(e) { super.unmaskedValue = e } get value() { return this._blocks.reduce((e, a) => e += a.value, "") } set value(e) { super.value = e } get displayValue() { return this._blocks.reduce((e, a) => e += a.displayValue, "") } appendTail(e) { return super.appendTail(e).aggregate(this._appendPlaceholder()) } _appendEager() { var e; const a = new E; let t = null == (e = this._mapPosToBlock(this.value.length)) ? void 0 : e.index; if (null == t) return a; this._blocks[t].isFilled && ++t; for (let e = t; e < this._blocks.length; ++e) { const t = this._blocks[e]._appendEager(); if (!t.inserted) break; a.aggregate(t) } return a } _appendCharRaw(e, a) { void 0 === a && (a = {}); const t = this._mapPosToBlock(this.value.length), n = new E; if (!t) return n; for (let l = t.index; ; ++l) { var s, r; const t = this._blocks[l]; if (!t) break; const o = t._appendChar(e, { ...a, _beforeTailState: null == (s = a._beforeTailState) || null == (r = s._blocks) ? void 0 : r[l] }), i = o.skip; if (n.aggregate(o), i || o.rawInserted) break } return n } extractTail(e, a) { void 0 === e && (e = 0), void 0 === a && (a = this.value.length); const t = new C; return e === a ? t : (this._forEachBlocksInRange(e, a, (e, a, n, s) => { const r = e.extractTail(n, s); r.stop = this._findStopBefore(a), r.from = this._blockStartPos(a), r instanceof C && (r.blockIndex = a), t.extend(r) }), t) } extractInput(e, a, t) { if (void 0 === e && (e = 0), void 0 === a && (a = this.value.length), void 0 === t && (t = {}), e === a) return ""; let n = ""; return this._forEachBlocksInRange(e, a, (e, a, s, r) => { n += e.extractInput(s, r, t) }), n } _findStopBefore(e) { let a; for (let t = 0; t < this._stops.length; ++t) { const n = this._stops[t]; if (n <= e) a = n; else break } return a } _appendPlaceholder(e) { const a = new E; if (this.lazy && null == e) return a; const t = this._mapPosToBlock(this.value.length); if (!t) return a; const n = t.index, s = null == e ? this._blocks.length : e; return this._blocks.slice(n, s).forEach(t => { if (!t.lazy || null != e) { var n; const e = t._appendPlaceholder(null == (n = t._blocks) ? void 0 : n.length); this._value += e.inserted, a.aggregate(e) } }), a } _mapPosToBlock(e) { let a = ""; for (let t = 0; t < this._blocks.length; ++t) { const n = this._blocks[t], s = a.length; if (a += n.value, e <= a.length) return { index: t, offset: e - s } } } _blockStartPos(e) { return this._blocks.slice(0, e).reduce((e, a) => e += a.value.length, 0) } _forEachBlocksInRange(e, a, t) { void 0 === a && (a = this.value.length); const n = this._mapPosToBlock(e); if (n) { const e = this._mapPosToBlock(a), s = e && n.index === e.index, r = n.offset, l = e && s ? e.offset : this._blocks[n.index].value.length; if (t(this._blocks[n.index], n.index, r, l), e && !s) { for (let a = n.index + 1; a < e.index; ++a)t(this._blocks[a], a, 0, this._blocks[a].value.length); t(this._blocks[e.index], e.index, 0, e.offset) } } } remove(e, a) { void 0 === e && (e = 0), void 0 === a && (a = this.value.length); const t = super.remove(e, a); return this._forEachBlocksInRange(e, a, (e, a, n, s) => { t.aggregate(e.remove(n, s)) }), t } nearestInputPos(e, a) { if (void 0 === a && (a = k.NONE), !this._blocks.length) return 0; const t = new T(this, e); if (a === k.NONE) return t.pushRightBeforeInput() ? t.pos : (t.popState(), t.pushLeftBeforeInput() ? t.pos : this.value.length); if (a === k.LEFT || a === k.FORCE_LEFT) { if (a === k.LEFT) { if (t.pushRightBeforeFilled(), t.ok && t.pos === e) return e; t.popState() } if (t.pushLeftBeforeInput(), t.pushLeftBeforeRequired(), t.pushLeftBeforeFilled(), a === k.LEFT) { if (t.pushRightBeforeInput(), t.pushRightBeforeRequired(), t.ok && t.pos <= e) return t.pos; if (t.popState(), t.ok && t.pos <= e) return t.pos; t.popState() } return t.ok ? t.pos : a === k.FORCE_LEFT ? 0 : (t.popState(), t.ok) ? t.pos : (t.popState(), t.ok ? t.pos : 0) } return a === k.RIGHT || a === k.FORCE_RIGHT ? (t.pushRightBeforeInput(), t.pushRightBeforeRequired(), t.pushRightBeforeFilled()) ? t.pos : a === k.FORCE_RIGHT ? this.value.length : (t.popState(), t.ok) ? t.pos : (t.popState(), t.ok ? t.pos : this.nearestInputPos(e, k.LEFT)) : e } totalInputPositions(e, a) { void 0 === e && (e = 0), void 0 === a && (a = this.value.length); let t = 0; return this._forEachBlocksInRange(e, a, (e, a, n, s) => { t += e.totalInputPositions(n, s) }), t } maskedBlock(e) { return this.maskedBlocks(e)[0] } maskedBlocks(e) { const a = this._maskedBlocks[e]; return a ? a.map(e => this._blocks[e]) : [] } } F.DEFAULTS = { lazy: !0, placeholderChar: "_" }, F.STOP_CHAR = "`", F.ESCAPE_CHAR = "\\", F.InputDefinition = x, F.FixedDefinition = b, o.MaskedPattern = F; class R extends F { get _matchFrom() { return this.maxLength - (this.from + "").length } constructor(e) { super(e) } updateOptions(e) { super.updateOptions(e) } _update(e) { const { to: t = this.to || 0, from: n = this.from || 0, maxLength: s = this.maxLength || 0, autofix: r = this.autofix, ...a } = e; this.to = t, this.from = n, this.maxLength = Math.max((t + "").length, s), this.autofix = r; const l = (this.from + "").padStart(this.maxLength, "0"), o = (this.to + "").padStart(this.maxLength, "0"); let i = 0; for (; i < o.length && o[i] === l[i];)++i; a.mask = o.slice(0, i).replace(/0/g, "\\0") + "0".repeat(this.maxLength - i), super._update(a) } get isComplete() { return super.isComplete && !!this.value } boundaries(e) { let a = "", t = ""; const [, n, s] = e.match(/^(\D*)(\d*)(\D*)/) || []; return s && (a = "0".repeat(n.length) + s, t = "9".repeat(n.length) + s), a = a.padEnd(this.maxLength, "0"), t = t.padEnd(this.maxLength, "9"), [a, t] } doPrepareChar(e, a) { void 0 === a && (a = {}); let t; if ([e, t] = super.doPrepareChar(e.replace(/\D/g, ""), a), !this.autofix || !e) return [e, t]; const n = (this.from + "").padStart(this.maxLength, "0"), s = (this.to + "").padStart(this.maxLength, "0"), r = this.value + e; if (r.length > this.maxLength) return ["", t]; const [l, o] = this.boundaries(r); return +o < this.from ? [n[r.length - 1], t] : +l > this.to ? "pad" === this.autofix && r.length < this.maxLength ? ["", t.aggregate(this.append(n[r.length - 1] + e, a))] : [s[r.length - 1], t] : [e, t] } doValidate(e) { const a = this.value, t = a.search(/[^0]/); if (-1 === t && a.length <= this._matchFrom) return !0; const [n, s] = this.boundaries(a); return this.from <= +s && +n <= this.to && super.doValidate(e) } } o.MaskedRange = R; class P extends F { constructor(e) { const { mask: t, pattern: n, ...s } = { ...P.DEFAULTS, ...e }; super({ ...s, mask: a(t) ? t : n }) } updateOptions(e) { super.updateOptions(e) } _update(e) { const { mask: t, pattern: n, blocks: s, ...r } = { ...P.DEFAULTS, ...e }, l = Object.assign({}, P.GET_DEFAULT_BLOCKS()); e.min && (l.Y.from = e.min.getFullYear()), e.max && (l.Y.to = e.max.getFullYear()), e.min && e.max && l.Y.from === l.Y.to && (l.m.from = e.min.getMonth() + 1, l.m.to = e.max.getMonth() + 1, l.m.from === l.m.to && (l.d.from = e.min.getDate(), l.d.to = e.max.getDate())), Object.assign(l, this.blocks, s), Object.keys(l).forEach(a => { const t = l[a]; !("autofix" in t) && "autofix" in e && (t.autofix = e.autofix) }), super._update({ ...r, mask: a(t) ? t : n, blocks: l }) } doValidate(e) { const a = this.date; return super.doValidate(e) && (!this.isComplete || this.isDateExist(this.value) && null != a && (null == this.min || this.min <= a) && (null == this.max || a <= this.max)) } isDateExist(e) { return 0 <= this.format(this.parse(e, this), this).indexOf(e) } get date() { return this.typedValue } set date(e) { this.typedValue = e } get typedValue() { return this.isComplete ? super.typedValue : null } set typedValue(e) { super.typedValue = e } maskEquals(e) { return e === Date || super.maskEquals(e) } } P.GET_DEFAULT_BLOCKS = () => ({ d: { mask: R, from: 1, to: 31, maxLength: 2 }, m: { mask: R, from: 1, to: 12, maxLength: 2 }, Y: { mask: R, from: 1900, to: 9999 } }), P.DEFAULTS = { mask: Date, pattern: "d{.}`m{.}`Y", format: e => { if (!e) return ""; const a = (e.getDate() + "").padStart(2, "0"), t = (e.getMonth() + 1 + "").padStart(2, "0"), n = e.getFullYear(); return [a, t, n].join(".") }, parse: e => { const [a, t, n] = e.split(".").map(Number); return new Date(n, t - 1, a) } }, o.MaskedDate = P; class V extends M { constructor(e) { super({ ...V.DEFAULTS, ...e }), this.currentMask = void 0 } updateOptions(e) { super.updateOptions(e) } _update(e) { super._update(e), "mask" in e && (this.compiledMasks = Array.isArray(e.mask) ? e.mask.map(e => d({ overwrite: this._overwrite, eager: this._eager, skipInvalid: this._skipInvalid, ...u(e) })) : []) } _appendCharRaw(e, a) { void 0 === a && (a = {}); const t = this._applyDispatch(e, a); return this.currentMask && t.aggregate(this.currentMask._appendChar(e, this.currentMaskFlags(a))), t } _applyDispatch(e, a, t) { void 0 === e && (e = ""), void 0 === a && (a = {}), void 0 === t && (t = ""); const n = a.tail && null != a._beforeTailState ? a._beforeTailState._value : this.value, s = this.rawInputValue, r = a.tail && null != a._beforeTailState ? a._beforeTailState._rawInputValue : s, l = s.slice(r.length), o = this.currentMask, i = new E, u = null == o ? void 0 : o.state; if (this.currentMask = this.doDispatch(e, { ...a }, t), this.currentMask) if (this.currentMask !== o) { if (this.currentMask.reset(), r) { const e = this.currentMask.append(r, { raw: !0 }); i.tailShift = e.inserted.length - n.length } l && (i.tailShift += this.currentMask.append(l, { raw: !0, tail: !0 }).tailShift) } else u && (this.currentMask.state = u); return i } _appendPlaceholder() { const e = this._applyDispatch(); return this.currentMask && e.aggregate(this.currentMask._appendPlaceholder()), e } _appendEager() { const e = this._applyDispatch(); return this.currentMask && e.aggregate(this.currentMask._appendEager()), e } appendTail(e) { const a = new E; return e && a.aggregate(this._applyDispatch("", {}, e)), a.aggregate(this.currentMask ? this.currentMask.appendTail(e) : super.appendTail(e)) } currentMaskFlags(e) { var a, t; return { ...e, _beforeTailState: (null == (a = e._beforeTailState) ? void 0 : a.currentMaskRef) === this.currentMask && (null == (t = e._beforeTailState) ? void 0 : t.currentMask) || e._beforeTailState } } doDispatch(e, a, t) { return void 0 === a && (a = {}), void 0 === t && (t = ""), this.dispatch(e, this, a, t) } doValidate(e) { return super.doValidate(e) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(e))) } doPrepare(e, a) { void 0 === a && (a = {}); let [t, n] = super.doPrepare(e, a); if (this.currentMask) { let e;[t, e] = super.doPrepare(t, this.currentMaskFlags(a)), n = n.aggregate(e) } return [t, n] } doPrepareChar(e, a) { void 0 === a && (a = {}); let [t, n] = super.doPrepareChar(e, a); if (this.currentMask) { let e;[t, e] = super.doPrepareChar(t, this.currentMaskFlags(a)), n = n.aggregate(e) } return [t, n] } reset() { var e; null == (e = this.currentMask) ? void 0 : e.reset(), this.compiledMasks.forEach(e => e.reset()) } get value() { return this.currentMask ? this.currentMask.value : "" } set value(e) { super.value = e } get unmaskedValue() { return this.currentMask ? this.currentMask.unmaskedValue : "" } set unmaskedValue(e) { super.unmaskedValue = e } get typedValue() { return this.currentMask ? this.currentMask.typedValue : "" } set typedValue(e) { let a = e + ""; this.currentMask && (this.currentMask.typedValue = e, a = this.currentMask.unmaskedValue), this.unmaskedValue = a } get displayValue() { return this.currentMask ? this.currentMask.displayValue : "" } get isComplete() { var e; return !(!(null != (e = this.currentMask)) || !e.isComplete) } get isFilled() { var e; return !(!(null != (e = this.currentMask)) || !e.isFilled) } remove(e, a) { const t = new E; return this.currentMask && t.aggregate(this.currentMask.remove(e, a)).aggregate(this._applyDispatch()), t } get state() { var e; return { ...super.state, _rawInputValue: this.rawInputValue, compiledMasks: this.compiledMasks.map(e => e.state), currentMaskRef: this.currentMask, currentMask: null == (e = this.currentMask) ? void 0 : e.state } } set state(e) { const { compiledMasks: a, currentMaskRef: t, currentMask: n, ...s } = e; a && this.compiledMasks.forEach((e, t) => e.state = a[t]), null != t && (this.currentMask = t, this.currentMask.state = n), super.state = s } extractInput(e, a, t) { return this.currentMask ? this.currentMask.extractInput(e, a, t) : "" } extractTail(e, a) { return this.currentMask ? this.currentMask.extractTail(e, a) : super.extractTail(e, a) } doCommit() { this.currentMask && this.currentMask.doCommit(), super.doCommit() } nearestInputPos(e, a) { return this.currentMask ? this.currentMask.nearestInputPos(e, a) : super.nearestInputPos(e, a) } get overwrite() { return this.currentMask ? this.currentMask.overwrite : this._overwrite } set overwrite(e) { this._overwrite = e } get eager() { return this.currentMask ? this.currentMask.eager : this._eager } set eager(e) { this._eager = e } get skipInvalid() { return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid } set skipInvalid(e) { this._skipInvalid = e } maskEquals(e) { return Array.isArray(e) ? this.compiledMasks.every((a, t) => { if (e[t]) { const { mask: n, ...s } = e[t]; return l(a, s) && a.maskEquals(n) } }) : super.maskEquals(e) } typedValueEquals(e) { var a; return !(!(null != (a = this.currentMask)) || !a.typedValueEquals(e)) } } V.DEFAULTS = void 0, V.DEFAULTS = { dispatch: (e, a, t, n) => { if (!a.compiledMasks.length) return; const s = a.rawInputValue, r = a.compiledMasks.map((r, l) => { const o = a.currentMask === r, i = o ? r.value.length : r.nearestInputPos(r.value.length, k.FORCE_LEFT); return r.rawInputValue === s ? !o && r.remove(i) : (r.reset(), r.append(s, { raw: !0 })), r.append(e, a.currentMaskFlags(t)), r.appendTail(n), { index: l, weight: r.rawInputValue.length, totalInputPositions: r.totalInputPositions(0, Math.max(i, r.nearestInputPos(r.value.length, k.FORCE_LEFT))) } }); return r.sort((e, a) => a.weight - e.weight || a.totalInputPositions - e.totalInputPositions), a.compiledMasks[r[0].index] } }, o.MaskedDynamic = V; class O extends F { updateOptions(e) { super.updateOptions(e) } _update(e) { const { enum: a, ...t } = e; a && (t.mask = "*".repeat(a[0].length), this.enum = a), super._update(t) } doValidate(e) { return this.enum.some(a => 0 <= a.indexOf(this.unmaskedValue)) && super.doValidate(e) } } o.MaskedEnum = O; class L extends M { updateOptions(e) { super.updateOptions(e) } _update(e) { super._update({ ...e, validate: e.mask }) } } o.MaskedFunction = L; class y extends M { constructor(e) { super({ ...y.DEFAULTS, ...e }) } updateOptions(e) { super.updateOptions(e) } _update(e) { super._update(e), this._updateRegExps() } _updateRegExps() { const e = "^" + (this.allowNegative ? "[+|\\-]?" : ""), a = (this.scale ? "(" + r(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$"; this._numberRegExp = new RegExp(e + "\\d*" + a), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(r).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(r(this.thousandsSeparator), "g") } _removeThousandsSeparators(e) { return e.replace(this._thousandsSeparatorRegExp, "") } _insertThousandsSeparators(e) { const a = e.split(this.radix); return a[0] = a[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), a.join(this.radix) } doPrepareChar(e, a) { void 0 === a && (a = {}), e = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (a.input && a.raw || !a.input && !a.raw) ? e.replace(this._mapToRadixRegExp, this.radix) : e); const [t, n] = super.doPrepareChar(e, a); return e && !t && (n.skip = !0), !t || this.allowPositive || this.value || "-" === t || n.aggregate(this._appendChar("-")), [t, n] } _separatorsCount(e, a) { void 0 === a && (a = !1); let t = 0; for (let n = 0; n < e; ++n)this._value.indexOf(this.thousandsSeparator, n) === n && (++t, a && (e += this.thousandsSeparator.length)); return t } _separatorsCountFromSlice(e) { return void 0 === e && (e = this._value), this._separatorsCount(this._removeThousandsSeparators(e).length, !0) } extractInput(e, a, t) { return void 0 === e && (e = 0), void 0 === a && (a = this.value.length), [e, a] = this._adjustRangeWithSeparators(e, a), this._removeThousandsSeparators(super.extractInput(e, a, t)) } _appendCharRaw(e, a) { if (void 0 === a && (a = {}), !this.thousandsSeparator) return super._appendCharRaw(e, a); const t = a.tail && a._beforeTailState ? a._beforeTailState._value : this._value, n = this._separatorsCountFromSlice(t); this._value = this._removeThousandsSeparators(this.value); const s = super._appendCharRaw(e, a); this._value = this._insertThousandsSeparators(this._value); const r = a.tail && a._beforeTailState ? a._beforeTailState._value : this._value, l = this._separatorsCountFromSlice(r); return s.tailShift += (l - n) * this.thousandsSeparator.length, s.skip = !s.rawInserted && e === this.thousandsSeparator, s } _findSeparatorAround(e) { if (this.thousandsSeparator) { const a = e - this.thousandsSeparator.length + 1, t = this.value.indexOf(this.thousandsSeparator, a); if (t <= e) return t } return -1 } _adjustRangeWithSeparators(e, a) { const t = this._findSeparatorAround(e); 0 <= t && (e = t); const n = this._findSeparatorAround(a); return 0 <= n && (a = n + this.thousandsSeparator.length), [e, a] } remove(e, a) { void 0 === e && (e = 0), void 0 === a && (a = this.value.length), [e, a] = this._adjustRangeWithSeparators(e, a); const t = this.value.slice(0, e), n = this.value.slice(a), s = this._separatorsCount(t.length); this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(t + n)); const r = this._separatorsCountFromSlice(t); return new E({ tailShift: (r - s) * this.thousandsSeparator.length }) } nearestInputPos(e, a) { if (!this.thousandsSeparator) return e; switch (a) { case k.NONE: case k.LEFT: case k.FORCE_LEFT: { const t = this._findSeparatorAround(e - 1); if (0 <= t) { const n = t + this.thousandsSeparator.length; if (e < n || this.value.length <= n || a === k.FORCE_LEFT) return t } break } case k.RIGHT: case k.FORCE_RIGHT: { const a = this._findSeparatorAround(e); if (0 <= a) return a + this.thousandsSeparator.length } }return e } doValidate(e) { let a = !!this._removeThousandsSeparators(this.value).match(this._numberRegExp); if (a) { const e = this.number; a = a && !isNaN(e) && (null == this.min || 0 <= this.min || this.min <= this.number) && (null == this.max || 0 >= this.max || this.number <= this.max) } return a && super.doValidate(e) } doCommit() { if (this.value) { const e = this.number; let a = e; null != this.min && (a = Math.max(a, this.min)), null != this.max && (a = Math.min(a, this.max)), a !== e && (this.unmaskedValue = this.format(a, this)); let t = this.value; this.normalizeZeros && (t = this._normalizeZeros(t)), this.padFractionalZeros && 0 < this.scale && (t = this._padFractionalZeros(t)), this._value = t } super.doCommit() } _normalizeZeros(e) { const a = this._removeThousandsSeparators(e).split(this.radix); return a[0] = a[0].replace(/^(\D*)(0*)(\d*)/, (e, a, t, n) => a + n), e.length && !/\d$/.test(a[0]) && (a[0] += "0"), 1 < a.length && (a[1] = a[1].replace(/0*$/, ""), !a[1].length && (a.length = 1)), this._insertThousandsSeparators(a.join(this.radix)) } _padFractionalZeros(e) { if (!e) return e; const a = e.split(this.radix); return 2 > a.length && a.push(""), a[1] = a[1].padEnd(this.scale, "0"), a.join(this.radix) } doSkipInvalid(e, a, t) { void 0 === a && (a = {}); const n = 0 === this.scale && e !== this.thousandsSeparator && (e === this.radix || e === y.UNMASKED_RADIX || this.mapToRadix.includes(e)); return super.doSkipInvalid(e, a, t) && !n } get unmaskedValue() { return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, y.UNMASKED_RADIX) } set unmaskedValue(e) { super.unmaskedValue = e } get typedValue() { return this.parse(this.unmaskedValue, this) } set typedValue(e) { this.rawInputValue = this.format(e, this).replace(y.UNMASKED_RADIX, this.radix) } get number() { return this.typedValue } set number(e) { this.typedValue = e } get allowNegative() { return null != this.min && 0 > this.min || null != this.max && 0 > this.max } get allowPositive() { return null != this.min && 0 < this.min || null != this.max && 0 < this.max } typedValueEquals(e) { return (super.typedValueEquals(e) || y.EMPTY_VALUES.includes(e) && y.EMPTY_VALUES.includes(this.typedValue)) && (0 !== e || "" !== this.value) } } y.UNMASKED_RADIX = ".", y.EMPTY_VALUES = [...M.EMPTY_VALUES, 0], y.DEFAULTS = { mask: Number, radix: ",", thousandsSeparator: "", mapToRadix: [y.UNMASKED_RADIX], min: Number.MIN_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, scale: 2, normalizeZeros: !0, padFractionalZeros: !1, parse: Number, format: e => e.toLocaleString("en-US", { useGrouping: !1, maximumFractionDigits: 20 }) }, o.MaskedNumber = y; const w = { MASKED: "value", UNMASKED: "unmaskedValue", TYPED: "typedValue" }; o.PIPE_TYPE = w, o.createPipe = p, o.pipe = c; try { globalThis.IMask = o } catch { } e.ChangeDetails = E, e.ChunksTailDetails = C, e.DIRECTION = k, e.HTMLContenteditableMaskElement = f, e.HTMLInputMaskElement = _, e.HTMLMaskElement = h, e.InputMask = v, e.MaskElement = m, e.Masked = M, e.MaskedDate = P, e.MaskedDynamic = V, e.MaskedEnum = O, e.MaskedFunction = L, e.MaskedNumber = y, e.MaskedPattern = F, e.MaskedRange = R, e.MaskedRegExp = I, e.PIPE_TYPE = w, e.PatternFixedDefinition = b, e.PatternInputDefinition = x, e.createMask = d, e.createPipe = p, e.default = o, e.forceDirection = s, e.normalizeOpts = u, e.pipe = c, Object.defineProperty(e, "__esModule", { value: !0 }) });